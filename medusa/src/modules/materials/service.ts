import { MedusaService } from "@medusajs/framework/utils"
import Material from "./models"

/**
 * MaterialsService - Medusa v2 Standard Implementation
 *
 * This service extends MedusaService and follows Medusa v2 best practices:
 * - Uses the service factory pattern with proper model registration
 * - Auto-generated CRUD methods via MedusaService
 * - Follows naming conventions: create[Model], list[Model]s, retrieve[Model], etc.
 */
export default class MaterialsService extends MedusaService({
  Material,
}) {
  /**
   * Custom business logic methods can be added here.
   * The following methods are automatically generated by MedusaService:
   *
   * - createMaterial(data): Create single material
   * - createMaterials(data[]): Create multiple materials
   * - retrieveMaterial(id, config?): Get material by ID
   * - listMaterials(filters?, config?): List materials with filtering
   * - updateMaterial(id, data): Update material
   * - updateMaterials(selector, data): Update multiple materials
   * - deleteMaterial(id): Delete material
   * - deleteMaterials(selector): Delete multiple materials
   */

  /**
   * Parse material names from composition strings
   * Example: "70% Cotton / 30% Linen" -> ["cotton", "linen"]
   */
  parseMaterialNames(input: string): string[] {
    if (!input || typeof input !== "string") return []

    const normalized = input
      .replace(/\u003c/gi, "<")
      .replace(/\u003e/gi, ">")
      .replace(/[<>\n\r\t]/g, " ")
      .trim()

    // Split by common separators
    const parts = normalized
      .split(/[,/|+;&]+/g)
      .flatMap((p) => p.split(/\band\b|\bwith\b|\bblend\b/gi))
      .map((p) => p.trim())
      .filter(Boolean)

    const cleaned = new Set<string>()
    for (const part of parts) {
      // Remove percentages and numbers
      let name = part.replace(/\d+%?/g, "").trim()
      // Keep alphabetic words only
      name = name.replace(/[^a-zA-Z\s-]/g, "").trim()
      if (!name) continue

      // Normalize common synonyms
      const n = name.toLowerCase()
      const materialMap: Record<string, string> = {
        "cotton": "cotton",
        "organic cotton": "cotton",
        "linen": "linen",
        "flax": "linen",
        "silk": "silk",
        "wool": "wool",
        "cashmere": "cashmere",
        "alpaca": "alpaca",
        "polyester": "polyester",
        "viscose": "viscose",
        "rayon": "rayon",
        "nylon": "nylon",
        "acrylic": "acrylic",
        "spandex": "spandex",
        "elastane": "spandex",
        "modal": "modal",
        "hemp": "hemp",
      }

      const canonical = materialMap[n] ?? n
      cleaned.add(canonical)
    }

    return Array.from(cleaned)
  }

  /**
   * Enhanced search functionality that searches across name and properties
   */
  async searchMaterials(
    query: string,
    options?: { limit?: number; offset?: number }
  ) {
    const searchQuery = {
      $or: [
        { name: { $ilike: `%${query}%` } },
        { properties: { $contains: query } }
      ]
    }

    return this.listMaterials(searchQuery, {
      take: options?.limit,
      skip: options?.offset,
    })
  }

  /**
   * Get materials by composition type
   */
  async getMaterialsByComposition(composition: string) {
    const materials = this.parseMaterialNames(composition)

    return this.listMaterials({
      name: { $in: materials }
    })
  }

  /**
   * List materials with pagination metadata
   */
  async listWithMeta(options: { limit?: number; offset?: number; q?: string; filters?: Record<string, any> } = {}) {
    const limit = typeof options.limit === "number" && options.limit > 0 ? Math.min(options.limit, 100) : 20
    const offset = typeof options.offset === "number" && options.offset >= 0 ? options.offset : 0

    const selector: any = { ...(options.filters || {}) }
    if (options.q && typeof options.q === "string" && options.q.trim().length >= 1) {
      // Use ilike on name when available
      selector.name = { $ilike: `%${options.q.trim()}%` }
    }

    // Count total (framework count may not be exposed; fallback to full list length)
    const all = await this.listMaterials(selector)
    const total = all.length

    const page = await this.listMaterials(selector, { take: limit, skip: offset })

    return {
      materials: page,
      count: total,
      pagination: {
        limit,
        offset,
        total,
        totalPages: Math.max(1, Math.ceil(total / Math.max(1, limit))),
        currentPage: Math.floor(offset / Math.max(1, limit)) + 1,
        hasNext: offset + limit < total,
        hasPrevious: offset > 0,
      },
    }
  }
}

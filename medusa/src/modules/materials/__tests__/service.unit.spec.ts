import MaterialsService from "../service"
import { moduleIntegrationTestRunner } from "@medusajs/test-utils"
import Material from "../models"

/**
 * Materials Service Unit Tests
 * Following Medusa v2 testing patterns
 */

// Minimal mock container with logger
const makeContainer = () => ({
  resolve: (k: string) => {
    if (k === "logger") {
      return {
        info: jest.fn(),
        error: jest.fn(),
        warn: jest.fn(),
        debug: jest.fn(),
      }
    }
    return undefined
  },
} as any)

describe("MaterialsService Unit Tests", () => {
  let service: MaterialsService

  beforeEach(() => {
    service = new MaterialsService(makeContainer())
  })

  describe("Service Initialization", () => {
    it("should initialize correctly", () => {
      expect(service).toBeDefined()
      expect(service).toBeInstanceOf(MaterialsService)
    })
  })

  describe("parseMaterialNames", () => {
    it("should parse simple composition", () => {
      const result = service.parseMaterialNames("100% Cotton")
      expect(result).toEqual(["cotton"])
    })

    it("should parse complex composition", () => {
      const result = service.parseMaterialNames("70% Cotton / 30% Linen")
      expect(result).toEqual(expect.arrayContaining(["cotton", "linen"]))
    })

    it("should handle synonyms correctly", () => {
      const result = service.parseMaterialNames("50% Elastane, 50% Spandex")
      expect(result).toEqual(["spandex"]) // Both should map to spandex
    })

    it("should handle empty input gracefully", () => {
      expect(service.parseMaterialNames("")).toEqual([])
      expect(service.parseMaterialNames(null as any)).toEqual([])
      expect(service.parseMaterialNames(undefined as any)).toEqual([])
    })

    it("should remove percentages and clean text", () => {
      const result = service.parseMaterialNames("95% Organic Cotton & 5% Wool")
      expect(result).toEqual(expect.arrayContaining(["cotton", "wool"]))
    })

    it("should handle multiple separators", () => {
      const result = service.parseMaterialNames("Cotton, Polyester | Spandex; Wool + Modal")
      expect(result.length).toBeGreaterThan(3)
      expect(result).toContain("cotton")
      expect(result).toContain("polyester")
    })

    it("should normalize material names", () => {
      const result = service.parseMaterialNames("Organic Cotton and Flax blend")
      expect(result).toContain("cotton") // Organic cotton -> cotton
      expect(result).toContain("linen")  // Flax -> linen
    })
  })

  describe("Service Methods Documentation", () => {
    it("should document auto-generated methods", () => {
      // The service should have these methods generated by MedusaService:
      const expectedMethods = [
        'createMaterial',
        'createMaterials',
        'retrieveMaterial',
        'listMaterials',
        'updateMaterial',
        'updateMaterials',
        'deleteMaterial',
        'deleteMaterials'
      ]

      expectedMethods.forEach(method => {
        expect(typeof (service as any)[method]).toBe('function')
      })
    })
  })
})

/**
 * Integration tests using Medusa test utilities
 * These tests require a test database setup
 */
moduleIntegrationTestRunner<MaterialsService>({
  moduleName: "materialsModuleService",
  moduleModels: [Material],
  resolve: "../",
  testSuite: ({ service }) => {
    describe("MaterialsService Integration Tests", () => {
      describe("CRUD Operations", () => {
        it("should create and retrieve materials", async () => {
          const materialData = {
            name: "cotton",
            properties: { type: "natural", care: "machine_washable" }
          }

          const created = await service.createMaterial(materialData)
          expect(created.name).toBe("cotton")
          expect(created.id).toBeDefined()
          expect(created.id).toMatch(/^mat_/)

          const retrieved = await service.retrieveMaterial(created.id)
          expect(retrieved.name).toBe("cotton")
          expect(retrieved.properties).toEqual(materialData.properties)
        })

        it("should create multiple materials", async () => {
          const materialsData = [
            { name: "cotton", properties: { type: "natural" } },
            { name: "polyester", properties: { type: "synthetic" } },
            { name: "wool", properties: { type: "natural" } }
          ]

          const created = await service.createMaterials(materialsData)
          expect(created).toHaveLength(3)
          expect(created.every(m => m.id && m.name)).toBe(true)
        })

        it("should list materials with filtering", async () => {
          // Create test materials
          await service.createMaterials([
            { name: "cotton", properties: { type: "natural" } },
            { name: "polyester", properties: { type: "synthetic" } },
            { name: "wool", properties: { type: "natural" } }
          ])

          // Test basic listing
          const allMaterials = await service.listMaterials()
          expect(allMaterials.length).toBeGreaterThanOrEqual(3)

          // Test filtering by name
          const cottonMaterials = await service.listMaterials({ name: "cotton" })
          expect(cottonMaterials.length).toBe(1)
          expect(cottonMaterials[0].name).toBe("cotton")
        })

        it("should update materials", async () => {
          const material = await service.createMaterial({
            name: "silk",
            properties: { type: "natural" }
          })

          const updated = await service.updateMaterial(material.id, {
            properties: { type: "natural", care: "dry_clean" }
          })

          expect(updated.properties.care).toBe("dry_clean")
        })

        it("should delete materials", async () => {
          const material = await service.createMaterial({
            name: "test_material",
            properties: {}
          })

          await service.deleteMaterial(material.id)

          await expect(service.retrieveMaterial(material.id))
            .rejects.toThrow()
        })
      })

      describe("Search Functionality", () => {
        beforeEach(async () => {
          // Setup test data
          await service.createMaterials([
            {
              name: "silk",
              properties: { description: "luxurious natural fiber", type: "natural" }
            },
            {
              name: "cotton",
              properties: { description: "comfortable everyday fabric", type: "natural" }
            },
            {
              name: "polyester",
              properties: { description: "durable synthetic material", type: "synthetic" }
            }
          ])
        })

        it("should search materials by name", async () => {
          const searchResults = await service.searchMaterials("silk")
          expect(searchResults.length).toBeGreaterThan(0)
          expect(searchResults[0].name).toBe("silk")
        })

        it("should search materials by properties", async () => {
          const searchResults = await service.searchMaterials("luxurious")
          expect(searchResults.length).toBeGreaterThan(0)
          expect(searchResults[0].name).toBe("silk")
        })

        it("should handle search pagination", async () => {
          const page1 = await service.searchMaterials("natural", { limit: 1, offset: 0 })
          const page2 = await service.searchMaterials("natural", { limit: 1, offset: 1 })

          expect(page1.length).toBe(1)
          expect(page2.length).toBe(1)
          expect(page1[0].id).not.toBe(page2[0].id)
        })
      })

      describe("Composition Analysis", () => {
        beforeEach(async () => {
          await service.createMaterials([
            { name: "cotton", properties: {} },
            { name: "linen", properties: {} },
            { name: "wool", properties: {} },
            { name: "polyester", properties: {} }
          ])
        })

        it("should find materials by composition", async () => {
          const composition = "60% Cotton, 40% Linen"
          const materials = await service.getMaterialsByComposition(composition)

          const names = materials.map(m => m.name)
          expect(names).toContain("cotton")
          expect(names).toContain("linen")
        })

        it("should handle complex compositions", async () => {
          const composition = "50% Wool, 30% Cotton, 20% Polyester"
          const materials = await service.getMaterialsByComposition(composition)

          expect(materials.length).toBeGreaterThanOrEqual(3)
          const names = materials.map(m => m.name)
          expect(names).toContain("wool")
          expect(names).toContain("cotton")
          expect(names).toContain("polyester")
        })
      })

      describe("Pagination and Limits", () => {
        beforeEach(async () => {
          // Create multiple materials for pagination testing
          const materials = Array.from({ length: 25 }, (_, i) => ({
            name: `material_${i.toString().padStart(2, '0')}`,
            properties: { index: i }
          }))
          await service.createMaterials(materials)
        })

        it("should handle pagination correctly", async () => {
          const page1 = await service.listMaterials({}, { take: 10 })
          const page2 = await service.listMaterials({}, { take: 10, skip: 10 })
          const page3 = await service.listMaterials({}, { take: 10, skip: 20 })

          expect(page1.length).toBe(10)
          expect(page2.length).toBe(10)
          expect(page3.length).toBeGreaterThan(0)

          // Ensure no overlap between pages
          const allIds = [...page1, ...page2, ...page3].map(m => m.id)
          const uniqueIds = new Set(allIds)
          expect(uniqueIds.size).toBe(allIds.length)
        })

        it("should respect take limits", async () => {
          const small = await service.listMaterials({}, { take: 5 })
          const large = await service.listMaterials({}, { take: 20 })

          expect(small.length).toBe(5)
          expect(large.length).toBe(20)
        })
      })
    })
  },
})